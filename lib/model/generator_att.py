# -*- coding: utf-8 -*-

import os
import random

import numpy as np

import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.autograd import Variable



class FeedForward(nn.Module):
    def __init__(self, input_size, hidden_size, num_classes):
        super(FeedForward, self).__init__()
        self.fc1 = nn.Linear(input_size, hidden_size) 
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(hidden_size, num_classes)  
    
    def forward(self, x):
        h1 = self.relu(self.fc1(x))
        out = self.fc2(h1)
        return out

class Generator(nn.Module):
    """Generator """

    def __init__(self, vocab_size, hidden_dim, embedding_dim, num_layers, use_cuda, mode='word', start_token=0):
        super(Generator, self).__init__()
        self.hidden_dim = hidden_dim
        self.num_layers = num_layers
        self.use_cuda = use_cuda
        self.start_token = start_token

        # Define embeddings
        self.emb = nn.Embedding(vocab_size, embedding_dim)

        if mode == "char":
            if vocab_size == embedding_dim:
                # One hot encodings
                self.emb.weight.data = torch.eye(vocab_size)
                self.emb.weight.requires_grad = False

        # Set number of layers to 1
        self.num_layers = 1

        # Map every word to an annotation
        self.lstm_enc = nn.LSTMCell(embedding_dim, hidden_dim)

        # Maintain hidden state for decoding distribution
        # Check input_dim (could do context and input??)
        # Context dim == hidden dim
        self.lstm_dec = nn.LSTMCell(hidden_dim, hidden_dim)

        # Init alignment model
        # We can precompute Ua * hj to save computation, CHECK PAPER
        # In our case we can store it until timestep
        self.alignment_model = FeedForward(hidden_dim + hidden_dim, hidden_dim, 1)

        self.linear = nn.Linear(hidden_dim, vocab_size)
        self.softmax = nn.LogSoftmax(dim=-1)
        self.init_params()

    def forward(self, x):
        """
        Args:
            x: (batch_size, seq_len), sequence of tokens generated by generator
        """
        emb = self.emb(x)
        h0, c0 = self.init_hidden(x.size(0))
        h1, c1 = self.init_hidden(self.hidden_dim)
        self.lstm.flatten_parameters()
        # First encode the sentence up to time t

        # MAKE TORCH TENSORS
        annotations = list()
        hidden_dec = list()
        for i in range(len(x)):
            e_i = list()
            h_enc, c_enc = self.lstm_enc(x[i], (h0, c0))
            annotations.append(h)
            # Create context vector
            for j in range(i - 1):
                e_ij = self.alignment_model(hidden_dec[i - 1], annotations[j])
                e_i.append(e_ij)
            
            a_i = nn.softmax(e_i)
            # SUM OVER J
            c_i = torch.sum(a_i * annotations)
            # Decode using other LSTM
            h_dec, c_dec = self.lstm_dec(c_i, (h1, c1))
            hidden_dec.append(h_dec)

        # FIX THIS AS TENSOR AND IN LOOP AS WELL
        pred = self.softmax(self.linear(output.contiguous().view(-1, self.hidden_dim)))
        return pred

    def step(self, x, h, c):
        """
        Args:
            x: (batch_size,  1), sequence of tokens generated by generator
            h: (1, batch_size, hidden_dim), lstm hidden state
            c: (1, batch_size, hidden_dim), lstm cell state
        """
        emb = self.emb(x)
        self.lstm.flatten_parameters()
        output, (h, c) = self.lstm(emb, (h, c))
        pred = self.softmax(self.linear(output.view(-1, self.hidden_dim)))
        return pred, h, c

    def init_hidden(self, batch_size):
        h = Variable(torch.zeros((self.num_layers, batch_size, self.hidden_dim)))
        c = Variable(torch.zeros((self.num_layers, batch_size, self.hidden_dim)))
        if self.use_cuda:
            h, c = h.cuda(), c.cuda()
        return h, c

    def init_params(self):
        for param in self.parameters():
            param.data.uniform_(-0.05, 0.05)

    def sample(self, batch_size, seq_len, x=None):
        res = []
        flag = False  # whether sample from zero
        if x is None:
            flag = True
        if flag:
            x = Variable(self.start_token * torch.ones((batch_size, 1)).long())
        if self.use_cuda:
            x = x.cuda()
        h, c = self.init_hidden(batch_size)
        samples = []
        if flag:
            for i in range(seq_len):
                output, h, c = self.step(x, h, c)
                x = output.multinomial(1)
                samples.append(x)
        else:
            given_len = x.size(1)
            lis = x.chunk(x.size(1), dim=1)
            for i in range(given_len):
                output, h, c = self.step(lis[i], h, c)
                samples.append(lis[i])
            x = output.multinomial(1)
            for i in range(given_len, seq_len):
                samples.append(x)
                output, h, c = self.step(x, h, c)
                x = output.multinomial(1)
        output = torch.cat(samples, dim=1)
        return output
